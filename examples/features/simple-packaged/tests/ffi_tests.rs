/*
 *  Copyright 2025-2026 Colliery Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

//! FFI Integration Tests
//!
//! Tests for the FFI functions generated by the packaged_workflow macro.

// Import the module to test FFI functions
use simple_packaged_demo::data_processing;

#[test]
fn test_workflow_creation_directly() {
    // Test the Workflow creation directly (without builder validation)
    let mut workflow = cloacina::workflow::Workflow::new("data_processing");
    workflow.set_tenant("test_tenant");
    workflow.set_package("simple_demo");

    // Finalize to calculate version
    let finalized_workflow = workflow.finalize();

    assert_eq!(finalized_workflow.name(), "data_processing");
    assert_eq!(finalized_workflow.tenant(), "test_tenant");
    assert_eq!(finalized_workflow.package(), "simple_demo");
    assert!(!finalized_workflow.metadata().version.is_empty());
}

#[test]
fn test_get_task_metadata_integration() {
    // Test that we can get task metadata and it contains expected tasks
    let metadata_ptr = unsafe { data_processing::get_task_metadata() };
    let metadata = unsafe { &*metadata_ptr };

    assert_eq!(metadata.task_count, 3);

    let tasks_slice =
        unsafe { std::slice::from_raw_parts(metadata.tasks, metadata.task_count as usize) };

    let mut task_names = Vec::new();
    for task in tasks_slice {
        let task_id = unsafe { std::ffi::CStr::from_ptr(task.local_id) }
            .to_str()
            .unwrap();
        task_names.push(task_id);
    }

    task_names.sort();
    assert_eq!(
        task_names,
        vec!["collect_data", "generate_report", "process_data"]
    );
}

#[test]
fn test_metadata_functions() {
    // Test metadata FFI function
    let metadata_ptr = unsafe { data_processing::get_package_metadata_abi_simple_demo() };
    assert!(
        !metadata_ptr.is_null(),
        "Metadata function should not return null"
    );

    // Test package metadata
    let metadata = data_processing::get_package_metadata();
    assert_eq!(metadata.package, "simple_demo");
    assert_eq!(metadata.tenant, "public");
    assert!(!metadata.description.is_empty());
    assert!(!metadata.author.is_empty());
    assert!(!metadata.fingerprint.is_empty());
}
