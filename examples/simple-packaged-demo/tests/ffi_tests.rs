/*
 *  Copyright 2025 Colliery Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

//! FFI Integration Tests
//!
//! Tests for the FFI functions generated by the packaged_workflow macro.

use std::ffi::CString;

// Import the module to test FFI functions
use simple_packaged_demo::data_processing;

#[test]
fn test_cloacina_create_workflow_with_host_managed_registry() {
    // Test parameters
    let tenant_id = CString::new("test_tenant").unwrap();
    let workflow_id = CString::new("data_processing").unwrap();

    // NEW APPROACH: Get task metadata and register in host registry
    let metadata_ptr = unsafe { data_processing::get_task_metadata() };
    let metadata = unsafe { &*metadata_ptr };

    // Simulate what the reconciler would do: register tasks in host global registry
    register_tasks_in_host_registry(metadata, "test_tenant");

    // Now call the FFI function - it should find tasks in host registry
    let workflow_ptr = unsafe {
        data_processing::cloacina_create_workflow(tenant_id.as_ptr(), workflow_id.as_ptr())
    };

    // Check that we got a valid pointer (not null)
    assert!(
        !workflow_ptr.is_null(),
        "cloacina_create_workflow should not return null"
    );

    // Convert back to a workflow to verify it's valid
    let workflow = unsafe { Box::from_raw(workflow_ptr as *mut cloacina::workflow::Workflow) };

    // Verify workflow properties
    assert_eq!(workflow.name(), "data_processing");
    assert_eq!(workflow.tenant(), "test_tenant");
    assert_eq!(workflow.package(), "simple_demo");

    // Verify the workflow has tasks (this proves the new approach works)
    let task_ids = workflow.get_task_ids();
    println!("Workflow has {} tasks: {:?}", task_ids.len(), task_ids);
    assert_eq!(
        task_ids.len(),
        3,
        "Workflow should have 3 tasks from host registry"
    );
}

/// Helper function to simulate what the reconciler does:
/// Register tasks from metadata into the host's global task registry
fn register_tasks_in_host_registry(
    metadata: &data_processing::TaskMetadataCollection,
    tenant_id: &str,
) {
    use std::ffi::CStr;

    let tasks_slice =
        unsafe { std::slice::from_raw_parts(metadata.tasks, metadata.task_count as usize) };

    for task in tasks_slice {
        // Extract task information
        let task_id = unsafe { CStr::from_ptr(task.local_id) }.to_str().unwrap();
        let constructor_name = unsafe { CStr::from_ptr(task.constructor_fn_name) }
            .to_str()
            .unwrap();

        // Create namespace for this task (same as reconciler would do)
        let namespace = cloacina::TaskNamespace::new(
            tenant_id,
            "simple_demo",     // package name
            "data_processing", // workflow name
            task_id,
        );

        // Register task constructor in host global registry
        // This simulates what the reconciler would do after getting metadata
        cloacina::register_task_constructor(
            namespace,
            create_task_constructor_for_function(constructor_name),
        );
    }
}

/// Create a task constructor that matches the generated constructor function name
fn create_task_constructor_for_function(
    constructor_name: &str,
) -> Box<dyn Fn() -> std::sync::Arc<dyn cloacina::Task> + Send + Sync> {
    match constructor_name {
        "collect_data_task" => Box::new(|| {
            std::sync::Arc::new(data_processing::collect_data_task())
                as std::sync::Arc<dyn cloacina::Task>
        }),
        "process_data_task" => Box::new(|| {
            std::sync::Arc::new(data_processing::process_data_task())
                as std::sync::Arc<dyn cloacina::Task>
        }),
        "generate_report_task" => Box::new(|| {
            std::sync::Arc::new(data_processing::generate_report_task())
                as std::sync::Arc<dyn cloacina::Task>
        }),
        _ => panic!("Unknown task constructor: {}", constructor_name),
    }
}

#[test]
fn test_cloacina_create_workflow_with_null_params() {
    // Test with null tenant_id
    let workflow_id = CString::new("test_workflow").unwrap();
    let workflow_ptr = unsafe {
        data_processing::cloacina_create_workflow(std::ptr::null(), workflow_id.as_ptr())
    };
    assert!(
        workflow_ptr.is_null(),
        "Should return null for null tenant_id"
    );

    // Test with null workflow_id
    let tenant_id = CString::new("test_tenant").unwrap();
    let workflow_ptr =
        unsafe { data_processing::cloacina_create_workflow(tenant_id.as_ptr(), std::ptr::null()) };
    assert!(
        workflow_ptr.is_null(),
        "Should return null for null workflow_id"
    );

    // Test with both null
    let workflow_ptr =
        unsafe { data_processing::cloacina_create_workflow(std::ptr::null(), std::ptr::null()) };
    assert!(
        workflow_ptr.is_null(),
        "Should return null for both null parameters"
    );
}

#[test]
fn test_cloacina_create_workflow_with_invalid_utf8() {
    // Create invalid UTF-8 strings
    let invalid_bytes = vec![0xff, 0xfe, 0xfd, 0x00]; // Invalid UTF-8 sequence ending with null
    let workflow_id = CString::new("test_workflow").unwrap();

    let workflow_ptr = unsafe {
        data_processing::cloacina_create_workflow(
            invalid_bytes.as_ptr() as *const std::os::raw::c_char,
            workflow_id.as_ptr(),
        )
    };
    assert!(
        workflow_ptr.is_null(),
        "Should return null for invalid UTF-8 tenant_id"
    );
}

#[test]
fn test_workflow_creation_directly() {
    // Test the Workflow creation directly (without builder validation)
    let mut workflow = cloacina::workflow::Workflow::new("data_processing");
    workflow.set_tenant("test_tenant");
    workflow.set_package("simple_demo");

    // Finalize to calculate version
    let finalized_workflow = workflow.finalize();

    assert_eq!(finalized_workflow.name(), "data_processing");
    assert_eq!(finalized_workflow.tenant(), "test_tenant");
    assert_eq!(finalized_workflow.package(), "simple_demo");
    assert!(!finalized_workflow.metadata().version.is_empty());
}

#[test]
fn test_get_task_metadata_integration() {
    // Test that we can get task metadata and it contains expected tasks
    let metadata_ptr = unsafe { data_processing::get_task_metadata() };
    let metadata = unsafe { &*metadata_ptr };

    assert_eq!(metadata.task_count, 3);

    let tasks_slice =
        unsafe { std::slice::from_raw_parts(metadata.tasks, metadata.task_count as usize) };

    let mut task_names = Vec::new();
    for task in tasks_slice {
        let task_id = unsafe { std::ffi::CStr::from_ptr(task.local_id) }
            .to_str()
            .unwrap();
        task_names.push(task_id);
    }

    task_names.sort();
    assert_eq!(
        task_names,
        vec!["collect_data", "generate_report", "process_data"]
    );
}

#[test]
fn test_metadata_functions() {
    // Test metadata FFI function
    let metadata_ptr = unsafe { data_processing::get_package_metadata_abi_simple_demo() };
    assert!(
        !metadata_ptr.is_null(),
        "Metadata function should not return null"
    );

    // Test package metadata
    let metadata = data_processing::get_package_metadata();
    assert_eq!(metadata.package, "simple_demo");
    assert_eq!(metadata.tenant, "public");
    assert!(!metadata.description.is_empty());
    assert!(!metadata.author.is_empty());
    assert!(!metadata.fingerprint.is_empty());
}
